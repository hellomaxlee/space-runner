<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Space Runner ‚Äî 3D (First Person)</title>
  <style>
    :root{
      --bg:#050914; --fg:#e6f1ff; --accent:#66e6ff; --accent2:#9b66ff; --ok:#6fffb7; --warn:#ffd166;
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 70% -10%,#0f1630 0%,#070b18 40%,#05080f 70%, #03050b 100%);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    #hud{position:fixed;inset:0;pointer-events:none}
    .panel{position:absolute;left:16px;top:16px;background:#0b1225cc;border:1px solid #1f2b4d;border-radius:12px;padding:10px 12px;backdrop-filter: blur(4px);}
    .panel h1{font-size:16px;margin:0 0 4px 0;letter-spacing:.05em;color:var(--accent)}
    .panel p{margin:2px 0;font-size:13px;opacity:.9}
    .progress{position:absolute;right:16px;top:16px;width:min(38vw,420px);height:14px;background:#101835;border-radius:999px;border:1px solid #1f2b4d;overflow:hidden}
    .progress > span{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--accent),var(--accent2));}
    .level{position:absolute;right:16px;top:40px;font-size:13px;opacity:.9}
    .center{position:absolute;inset:0;display:grid;place-items:center;text-align:center;padding:20px}
    .btn{pointer-events:auto;display:inline-block;margin-top:14px;padding:10px 14px;border-radius:12px;border:1px solid #2b3a6a;background:#0e1733;color:var(--fg);text-decoration:none;font-weight:600}
    .btn:hover{filter:brightness(1.1)}
    .toast{position:absolute;left:50%;transform:translateX(-50%);bottom:16px;background:#0b1225cc;border:1px solid #1f2b4d;border-radius:12px;padding:8px 12px;font-size:13px}
    .muted{opacity:.85}
    .power{position:absolute;right:16px;top:66px;font-size:13px;opacity:.9}
  </style>
</head>
<body>
  <div id="hud">
    <div class="panel" id="panel">
      <h1>Space Runner ‚Äî 3D</h1>
      <p><strong>Goal:</strong> Reach the end of each sector by avoiding <em>holes</em> in the platforms.</p>
      <p class="muted">Controls: <kbd>A</kbd>/<kbd>‚Üê</kbd> left ‚Ä¢ <kbd>D</kbd>/<kbd>‚Üí</kbd> right. (Forward key does nothing.)</p>
      <p class="muted">Tip: Pick up <span style="color:var(--ok)">powerups</span> for shields and slow-mo. This version is intentionally easier to beat. üôÇ</p>
    </div>
    <div class="progress" aria-label="Level progress"><span id="prog"></span></div>
    <div class="level" id="levelLabel">Level 1 / 5</div>
    <div class="power" id="powerLabel"></div>
    <div class="center" id="overlay">
      <div>
        <h2 style="margin:0 0 10px 0">Ready?</h2>
        <div class="muted">First-person runner in space. Dodge gaps, grab powerups, finish 5 sectors.</div>
        <a class="btn" id="startBtn" href="#">Start</a>
      </div>
    </div>
    <div class="toast muted" id="toast" style="display:none"></div>
  </div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>

<script>
(() => {
  // ----- THREE setup -----
  let scene, camera, renderer;
  const world = { laneX:[-4,0,4], z:0 };
  let W = window.innerWidth, H = window.innerHeight;

  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x050914, 10, 180);

  camera = new THREE.PerspectiveCamera(70, W/H, 0.1, 500);
  camera.position.set(0, 2.2, 6); // slightly behind the player position, looking forward

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setSize(W,H); renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  window.addEventListener('resize', () => {
    W = window.innerWidth; H = window.innerHeight;
    camera.aspect = W/H; camera.updateProjectionMatrix();
    renderer.setSize(W,H);
  });

  // Lighting & background stars
  const light = new THREE.HemisphereLight(0x88bbff, 0x101020, 0.8); scene.add(light);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(2,4,3); scene.add(dir);

  const starGeo = new THREE.BufferGeometry();
  const starCount = 800;
  const starPos = new Float32Array(starCount*3);
  for (let i=0;i<starCount;i++){ starPos[i*3]= (Math.random()-0.5)*80; starPos[i*3+1]= Math.random()*60; starPos[i*3+2]= -Math.random()*400; }
  starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
  const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color:0xe6f1ff, size:0.6 }));
  scene.add(stars);

  // ----- Game state -----
  const LANES = 3;
  const player = { lane:1, x:0, y:1.2, z:0, alive:true, shield:false, slowMo:0 };
  const levels = [
    { length: 600, speed: 12, holeFreq: 0.12, holeLen:[5,9] },
    { length: 750, speed: 13, holeFreq: 0.16, holeLen:[5,9] },
    { length: 900, speed: 14, holeFreq: 0.18, holeLen:[5,10] },
    { length:1050, speed: 15, holeFreq: 0.22, holeLen:[6,11] },
    { length:1200, speed: 16, holeFreq: 0.24, holeLen:[6,12] },
  ]; // tuned to be forgiving
  let currentLevel = 0;
  let distance = 0;           // meters progressed this level
  let running = false;
  let finished = false;
  let last = performance.now();

  // HUD
  const overlay = document.getElementById('overlay');
  const progBar = document.getElementById('prog');
  const levelLabel = document.getElementById('levelLabel');
  const powerLabel = document.getElementById('powerLabel');
  const toast = document.getElementById('toast');
  document.getElementById('startBtn').addEventListener('click', e=>{ e.preventDefault(); startGame(); });

  function setLevelLabel(){ levelLabel.textContent = `Level ${currentLevel+1} / ${levels.length}`; }

  function showToast(msg){
    toast.textContent = msg; toast.style.display='block';
    clearTimeout(showToast._t); showToast._t = setTimeout(()=> toast.style.display='none', 1100);
  }

  // ----- Track generation -----
  const SEG = 4;                  // segment length (meters)
  const LOOKAHEAD = 220;          // how far to build track
  const laneGroups = [new THREE.Group(), new THREE.Group(), new THREE.Group()];
  laneGroups.forEach((g,i)=>{ g.position.x = world.laneX[i]; scene.add(g); });

  const platMat = new THREE.MeshStandardMaterial({ color:0x20305a, metalness:0.2, roughness:0.7 });
  const holeMat = new THREE.MeshStandardMaterial({ color:0x0a0f24, metalness:0.1, roughness:1.0 });
  const geom = new THREE.BoxGeometry(2.2, 0.2, SEG);

  const powerups = []; // {mesh,type,z,lane}
  const powGeom = new THREE.IcosahedronGeometry(0.35, 0);
  const powMats = {
    shield: new THREE.MeshStandardMaterial({ color:0x6fffb7, emissive:0x113322, emissiveIntensity:0.6 }),
    slow:   new THREE.MeshStandardMaterial({ color:0xffd166, emissive:0x332211, emissiveIntensity:0.6 })
  };

  // track data per lane: array of segments {z, hasPlatform, hasPower: 'shield'|'slow'|null}
  const lanes = [[],[],[]];

  function resetLevel(idx){
    currentLevel = idx; distance = 0; player.alive = true; player.shield=false; player.slowMo=0; running=true; finished=false;
    setLevelLabel(); powerLabel.textContent='';
    // clear scene children from lanes & powerups
    laneGroups.forEach(g=>{ while(g.children.length) g.remove(g.children[0]); });
    powerups.splice(0,powerups.length);
    lanes.forEach(arr=>arr.splice(0,arr.length));
    // prebuild some safe track at start
    for (let z=0; z<60; z+=SEG){
      for (let L=0;L<LANES;L++) addSegment(L, z, true);
    }
  }

  function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }

  function addSegment(lane, z, forceSolid=false){
    const cfg = levels[currentLevel];
    let solid = forceSolid || Math.random() > cfg.holeFreq;
    // ensure holes are not too long or immediately at start
    if (z < 40) solid = true;

    // build mesh
    const g = solid ? geom : geom; // always place something; if hole, we place a dark "gap" slab slightly lower for visual depth
    const m = new THREE.Mesh(g, solid?platMat:holeMat);
    m.position.set(0, solid?0: -0.02, -z);
    laneGroups[lane].add(m);

    // occasional powerups on solid tiles
    let pow = null;
    if (solid && Math.random() < 0.06){
      const type = Math.random()<0.5 ? 'shield' : 'slow';
      const pm = new THREE.Mesh(powGeom, powMats[type]);
      pm.position.set(world.laneX[lane], 0.9, -(z + SEG*0.5));
      pm.rotation.set(Math.random(), Math.random(), Math.random());
      scene.add(pm);
      pow = {mesh:pm, type, z: z+SEG*0.5, lane};
      powerups.push(pow);
    }

    lanes[lane].push({ z, solid, pow });
  }

  function ensureLookahead(){
    const buildUpto = distance + LOOKAHEAD;
    const lastZ = lanes[0].length ? lanes[0][lanes[0].length-1].z : 0;
    for (let z = lastZ + SEG; z < buildUpto; z += SEG){
      for (let L=0; L<LANES; L++) addSegment(L, z);
    }
  }

  // ----- Player & input -----
  const keys = new Set();
  window.addEventListener('keydown', (e)=>{
    if (["ArrowLeft","ArrowRight","a","A","d","D","ArrowUp","ArrowDown"].includes(e.key)) e.preventDefault();
    if (!running && e.key===' ') { startGame(); return; }

    if (e.key==='ArrowLeft' || e.key==='a' || e.key==='A') moveLane(-1);
    if (e.key==='ArrowRight'|| e.key==='d' || e.key==='D') moveLane(1);
    if (e.key==='ArrowUp' || e.key==='ArrowDown') { /* do nothing on purpose */ }
  });

  function moveLane(dir){
    player.lane = Math.max(0, Math.min(LANES-1, player.lane + dir));
    player.x = world.laneX[player.lane];
    showToast(dir<0? 'Left' : 'Right');
  }

  // visual player marker (nose of the craft/animal; camera is FP but this helps alignment)
  const noseGeo = new THREE.ConeGeometry(0.2, 0.6, 16);
  const noseMat = new THREE.MeshStandardMaterial({ color:0x66e6ff, emissive:0x112244, emissiveIntensity:0.5 });
  const nose = new THREE.Mesh(noseGeo, noseMat); scene.add(nose); nose.rotation.x = Math.PI/2; nose.position.set(0,1.0, 0.2);

  // ----- Game flow -----
  function startGame(){ resetLevel(0); overlay.style.display='none'; last=performance.now(); requestAnimationFrame(loop); }

  function completeGame(){ running=false; finished=true; overlay.style.display='grid';
    overlay.querySelector('div').innerHTML = `
      <h2 style="margin:0 0 10px 0">Mission Complete!</h2>
      <div class="muted">You cleared all sectors. GG.</div>
      <a class="btn" id="againBtn" href="#">Play Again</a>`;
    overlay.querySelector('#againBtn').addEventListener('click', e=>{ e.preventDefault(); startGame(); });
  }

  function crash(){ if(!player.alive) return; player.alive=false; running=false; overlay.style.display='grid';
    overlay.querySelector('div').innerHTML = `
      <h2 style="margin:0 0 10px 0">You Fell!</h2>
      <div class="muted">Mind the gaps. Try again‚Äîthis version is easier.</div>
      <a class="btn" id="retryBtn" href="#">Retry Level</a>`;
    overlay.querySelector('#retryBtn').addEventListener('click', e=>{ e.preventDefault(); overlay.style.display='none'; player.alive=true; running=true; last=performance.now(); requestAnimationFrame(loop); });
  }

  // ----- Loop -----
  function loop(ts){
    if (!running) return;
    const dt = Math.min(40, ts-last); last = ts;
    const cfg = levels[currentLevel];

    // speed & slow-mo
    if (player.slowMo>0) player.slowMo = Math.max(0, player.slowMo - dt/1000);
    const speed = (player.slowMo>0 ? cfg.speed*0.55 : cfg.speed);

    distance += (speed * dt/1000) * 4;  // meters per second scaled
    ensureLookahead();

    // move camera forward
    camera.position.z -= (speed * dt/1000) * 4;
    world.z = -camera.position.z; // positive forward distance

    // update player marker alignment
    nose.position.set(world.laneX[player.lane], 1.0, camera.position.z - 1.4);

    // remove passed segments + check floor under player
    for (let L=0; L<LANES; L++){
      const arr = lanes[L];
      while (arr.length && (arr[0].z + SEG) < world.z - 6){ // far behind camera
        const seg = arr.shift();
        const grp = laneGroups[L];
        if (grp.children.length) grp.remove(grp.children[0]);
      }
    }

    // collision with gap (no floor)
    const laneArr = lanes[player.lane];
    const zAhead = world.z + 1.4; // a little ahead of camera
    let onFloor = true;
    for (let i=0;i<laneArr.length;i++){
      const seg = laneArr[i];
      if (zAhead >= seg.z && zAhead < seg.z + SEG){ onFloor = seg.solid; break; }
    }

    // powerups
    for (let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      if (Math.abs(p.z - zAhead) < 1.0 && p.lane === player.lane){
        if (p.type==='shield'){ player.shield=true; powerLabel.textContent='Shield active (one save)'; }
        if (p.type==='slow'){ player.slowMo = 3.2; powerLabel.textContent='Slow-mo 3s'; }
        scene.remove(p.mesh); powerups.splice(i,1);
      } else if (p.z < world.z - 6){ scene.remove(p.mesh); powerups.splice(i,1); }
      else { p.mesh.rotation.x += 0.01; p.mesh.rotation.y += 0.02; }
    }

    if (!onFloor){
      if (player.shield){ player.shield=false; powerLabel.textContent=''; // forgive once and fill gap visually for feedback
        // create a temporary bridge tile to save the player
        const bridge = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({ color:0x2a6d6d }));
        bridge.position.set(world.laneX[player.lane], 0, -(Math.floor(zAhead/SEG)*SEG));
        scene.add(bridge); setTimeout(()=> scene.remove(bridge), 800);
      } else {
        return crash();
      }
    }

    // level complete
    if (distance >= levels[currentLevel].length){
      if (currentLevel < levels.length-1){ currentLevel++; setLevelLabel(); resetLevel(currentLevel); showToast(`Level ${currentLevel} start`); }
      else { return completeGame(); }
    }

    // HUD progress
    const pct = Math.min(1, distance / levels[currentLevel].length);
    progBar.style.width = (pct*100).toFixed(2) + '%';

    // tiny star drift
    stars.position.z += 0.1;

    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }

  // ----- Kickoff instructions -----
  function showStart(){ overlay.style.display='grid'; }
  showStart();

})();
</script>
</body>
</html>
