<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Space Runner — 3D (First Person)</title>
  <style>
    :root{ --bg:#050914; --fg:#e6f1ff; --accent:#66e6ff; --accent2:#9b66ff; }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 70% -10%,#0f1630 0%,#070b18 40%,#05080f 70%, #03050b 100%);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    #hud{position:fixed;inset:0;pointer-events:none}
    .panel{position:absolute;left:16px;top:16px;background:#0b1225cc;border:1px solid #1f2b4d;border-radius:12px;padding:10px 12px;backdrop-filter: blur(4px);} 
    .panel h1{font-size:16px;margin:0 0 4px 0;letter-spacing:.05em;color:var(--accent)}
    .panel p{margin:2px 0;font-size:13px;opacity:.9}
    .progress{position:absolute;right:16px;top:16px;width:min(38vw,420px);height:14px;background:#101835;border-radius:999px;border:1px solid #1f2b4d;overflow:hidden}
    .progress > span{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--accent),var(--accent2));}
    .level{position:absolute;right:16px;top:40px;font-size:13px;opacity:.9}
    .center{position:absolute;inset:0;display:grid;place-items:center;text-align:center;padding:20px}
    .btn{pointer-events:auto;display:inline-block;margin-top:14px;padding:10px 14px;border-radius:12px;border:1px solid #2b3a6a;background:#0e1733;color:var(--fg);text-decoration:none;font-weight:600}
    .btn:hover{filter:brightness(1.1)}
    .toast{position:absolute;left:50%;transform:translateX(-50%);bottom:16px;background:#0b1225cc;border:1px solid #1f2b4d;border-radius:12px;padding:8px 12px;font-size:13px}
    .muted{opacity:.85}
  </style>
</head>
<body>
  <div id="hud">
    <div class="panel" id="panel">
      <h1>Space Runner — 3D</h1>
      <p><strong>Goal:</strong> Reach the end of each sector. Avoid <em>holes</em> in the unified platform. Touching a wall will rotate your world (Run 2 style).</p>
      <p class="muted">Controls: <kbd>A</kbd>/<kbd>←</kbd> left • <kbd>D</kbd>/<kbd>→</kbd> right • <kbd>Space</kbd> jump. (Forward/back keys do nothing.)</p>
    </div>
    <div class="progress" aria-label="Level progress"><span id="prog"></span></div>
    <div class="level" id="levelLabel">Level 1 / 5</div>
    <div class="center" id="overlay">
      <div>
        <h2 style="margin:0 0 10px 0">Ready?</h2>
        <div class="muted">First-person corridor runner. One continuous platform, solid walls, realistic jump, 5 sectors.</div>
        <a class="btn" id="startBtn" href="#">Start</a>
      </div>
    </div>
    <div class="toast muted" id="toast" style="display:none"></div>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>

<script>
(() => {
  // ---------- THREE Setup ----------
  let scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x050914, 12, 220);

  let W = innerWidth, H = innerHeight;
  const camera = new THREE.PerspectiveCamera(70, W/H, 0.1, 800);
  camera.position.set(0, 1.4, 6);

  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setSize(W,H); renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  addEventListener('resize', ()=>{ W=innerWidth; H=innerHeight; camera.aspect=W/H; camera.updateProjectionMatrix(); renderer.setSize(W,H);});

  // Lights & stars
  scene.add(new THREE.HemisphereLight(0x88bbff, 0x101020, 0.9));
  const sun = new THREE.DirectionalLight(0xffffff, 0.6); sun.position.set(2,4,3); scene.add(sun);
  const starGeo = new THREE.BufferGeometry();
  const starPos = new Float32Array(1500*3);
  for (let i=0;i<1500;i++){ starPos[i*3]=(Math.random()-0.5)*160; starPos[i*3+1]=(Math.random()-0.5)*160; starPos[i*3+2]=-Math.random()*800; }
  starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
  const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ size:0.6, color:0xe6f1ff }));
  scene.add(stars);

  // ---------- World params ----------
  const CORRIDOR_HALF = 3;        // half width of floor (x in [-3,3])
  const WALL_X = CORRIDOR_HALF;   // walls at ±3
  const SEG = 4;                  // segment length in meters
  const LOOKAHEAD = 260;          // how far to build ahead of the camera

  const materials = {
    floor: new THREE.MeshStandardMaterial({ color:0x20305a, roughness:0.75, metalness:0.2 }),
    wall:  new THREE.MeshStandardMaterial({ color:0x1a2547, roughness:0.8, metalness:0.15 }),
    hole:  new THREE.MeshStandardMaterial({ color:0x090f20 })
  };

  const geom = {
    tile: new THREE.BoxGeometry(CORRIDOR_HALF*2, 0.2, SEG),
    wall: new THREE.BoxGeometry(0.2, CORRIDOR_HALF*2, SEG),
    nose: new THREE.ConeGeometry(0.18, 0.5, 18)
  };

  // Root group we rotate when switching surfaces
  const world = new THREE.Group(); scene.add(world);

  // Groups for surfaces
  const gFloor = new THREE.Group(); world.add(gFloor);
  const gWallL = new THREE.Group(); world.add(gWallL);
  const gWallR = new THREE.Group(); world.add(gWallR);

  // ---------- Level config (easier) ----------
  const levels = [
    { length: 700, speed: 11, holeFreq: 0.1,   minGap: 2, maxGap: 3 },
    { length: 900, speed: 12, holeFreq: 0.12,  minGap: 2, maxGap: 3 },
    { length:1100, speed: 13, holeFreq: 0.14,  minGap: 2, maxGap: 3 },
    { length:1300, speed: 14, holeFreq: 0.17,  minGap: 2, maxGap: 3 },
    { length:1500, speed: 15, holeFreq: 0.19,  minGap: 2, maxGap: 3 }
  ];

  let currentLevel = 0;
  let distance = 0;     // meters within level
  let lastBuiltZ = 0;   // farthest z we've generated tiles to

  // Track data: floor holes only; walls are solid
  const floorSegs = []; // array of {z, solid}

  function resetLevel(idx){
    currentLevel = idx; distance = 0; lastBuiltZ = 0;
    // clear groups
    [gFloor,gWallL,gWallR].forEach(g=>{ while(g.children.length) g.remove(g.children[0]); });
    floorSegs.length = 0;
    // build safe start
    for (let z=0; z<40; z+=SEG){ addSegment(z, true); }
  }

  function addSegment(z, forceSolid=false){
    const cfg = levels[currentLevel];
    const makeHole = !forceSolid && Math.random()<cfg.holeFreq;

    // floor tile or gap (visual hole slab lower for depth)
    const m = new THREE.Mesh(geom.tile, makeHole? materials.hole : materials.floor);
    m.position.set(0, makeHole? -0.05 : 0, -z);
    gFloor.add(m);
    floorSegs.push({ z, solid: !makeHole });

    // walls for this z (always solid)
    const wl = new THREE.Mesh(geom.wall, materials.wall); wl.position.set(-WALL_X, CORRIDOR_HALF, -z); gWallL.add(wl);
    const wr = new THREE.Mesh(geom.wall, materials.wall); wr.position.set( WALL_X, CORRIDOR_HALF, -z); gWallR.add(wr);

    lastBuiltZ = Math.max(lastBuiltZ, z);
  }

  function ensureLookahead(camZ){
    const ahead = -camZ + LOOKAHEAD;
    for (let z = lastBuiltZ + SEG; z < ahead; z += SEG){
      // guarantee spacing between holes (minGap segments of solid between holes)
      const prev = floorSegs[floorSegs.length-1];
      const forceSolid = (prev && !prev.solid) ? true : false; // ensure at least one solid after a hole
      addSegment(z, forceSolid);
    }
  }

  // ---------- Player & physics ----------
  const player = {
    pos: new THREE.Vector3(0, 0.0, 0), // relative to floor frame
    vel: new THREE.Vector3(0, 0, 0),
    speedZ: 16,          // forward m/s in world forward
    grounded: true,
    surface: 0           // 0=floor (gravity -y), 1=right wall (-x), 2=ceiling (+y), 3=left wall (+x)
  };

  const GRAV = 28;       // m/s^2 (arcade-ish but feels good)
  const MOVE = 14;       // lateral m/s when holding A/D
  const JUMP = 9.5;      // m/s initial jump impulse
  const DAMP = 0.9;      // lateral damping when no input

  const keys = new Set();
  addEventListener('keydown', (e)=>{
    if (["ArrowLeft","ArrowRight","a","A","d","D"," ","ArrowUp","ArrowDown"].includes(e.key)) e.preventDefault();
    if (!running && e.key===' ') { startGame(); return; }
    if (e.key===' ' && player.grounded){ jump(); }
    if (e.key==='ArrowLeft' || e.key==='a' || e.key==='A') keys.add('L');
    if (e.key==='ArrowRight'|| e.key==='d' || e.key==='D') keys.add('R');
  });
  addEventListener('keyup', (e)=>{
    if (e.key==='ArrowLeft' || e.key==='a' || e.key==='A') keys.delete('L');
    if (e.key==='ArrowRight'|| e.key==='d' || e.key==='D') keys.delete('R');
  });

  function jump(){
    player.grounded = false;
    // impulse opposite gravity (outward from surface)
    if (player.surface===0) player.vel.y =  JUMP;
    if (player.surface===2) player.vel.y = -JUMP;
    if (player.surface===1) player.vel.x =  JUMP;
    if (player.surface===3) player.vel.x = -JUMP;
  }

  // visual nose marker to help judge edges
  const nose = new THREE.Mesh(geom.nose, new THREE.MeshStandardMaterial({ color:0x66e6ff, emissive:0x112244, emissiveIntensity:0.5 }));
  scene.add(nose); nose.rotation.x = Math.PI/2; nose.position.set(0,0.9, 0.3);

  // HUD
  const overlay = document.getElementById('overlay');
  const progBar = document.getElementById('prog');
  const levelLabel = document.getElementById('levelLabel');
  const toast = document.getElementById('toast');
  function setLevelLabel(){ levelLabel.textContent = `Level ${currentLevel+1} / ${levels.length}`; }
  function showToast(msg){ toast.textContent = msg; toast.style.display='block'; clearTimeout(showToast._t); showToast._t=setTimeout(()=> toast.style.display='none', 1100); }

  // Run-state
  let running = false; let last = performance.now();

  function startGame(){ resetLevel(0); running=true; overlay.style.display='none'; last=performance.now(); requestAnimationFrame(loop); }
  function completeGame(){ running=false; overlay.style.display='grid'; overlay.querySelector('div').innerHTML = `<h2 style="margin:0 0 10px 0">Mission Complete!</h2><div class="muted">You cleared all sectors.</div><a class="btn" id="againBtn" href="#">Play Again</a>`; overlay.querySelector('#againBtn').addEventListener('click', e=>{ e.preventDefault(); startGame();}); }
  function crash(){ running=false; overlay.style.display='grid'; overlay.querySelector('div').innerHTML = `<h2 style="margin:0 0 10px 0">You Fell!</h2><div class="muted">Space is unforgiving. Try again.</div><a class="btn" id="retryBtn" href="#">Retry Level</a>`; overlay.querySelector('#retryBtn').addEventListener('click', e=>{ e.preventDefault(); overlay.style.display='none'; running=true; last=performance.now(); requestAnimationFrame(loop); }); }

  function applyGravity(dt){
    const g = GRAV*dt;
    if (player.surface===0) player.vel.y -= g;
    if (player.surface===2) player.vel.y += g;
    if (player.surface===1) player.vel.x -= g;
    if (player.surface===3) player.vel.x += g;
  }
  function lateralAxis(){ return (player.surface===0||player.surface===2) ? 'x' : 'y'; }
  function normalAxis(){ return (player.surface===0||player.surface===2) ? 'y' : 'x'; }
  function clamp(val,min,max){ return Math.max(min, Math.min(max,val)); }

  function updatePhysics(dt){
    // forward motion
    const cfg = levels[currentLevel];
    const fwd = cfg.speed * dt * 4; // meters this frame
    camera.position.z -= fwd; distance += fwd;

    // ensure world built
    ensureLookahead(camera.position.z);

    // lateral input
    const axis = lateralAxis();
    if (keys.has('L')) player.vel[axis] = -MOVE;
    else if (keys.has('R')) player.vel[axis] =  MOVE;
    else player.vel[axis] *= DAMP;

    // gravity
    applyGravity(dt);

    // integrate
    player.pos.x += player.vel.x * dt;
    player.pos.y += player.vel.y * dt;

    // wall wrap / rotate world if we reach side
    if (player.surface===0 || player.surface===2){
      if (player.pos.x <= -WALL_X) rotateWorld(-1); // left wall
      if (player.pos.x >=  WALL_X) rotateWorld( 1); // right wall
    } else {
      // on walls, clamp y to corridor height; if exceed, rotate to ceiling/floor
      if (player.pos.y >=  CORRIDOR_HALF) rotateWorld(1);    // to ceiling when on right wall, or to floor when on left wall (handled in rotateWorld)
      if (player.pos.y <= -CORRIDOR_HALF) rotateWorld(-1);
    }

    // collision with surface (only floor has holes; walls always solid)
    const nAxis = normalAxis();
    const posN = player.pos[nAxis];

    if (player.surface===0){ // floor at y=0
      const zAhead = -camera.position.z + 1.2; // sampling point slightly ahead
      const seg = getFloorSegAt(zAhead);
      const onTile = seg && seg.solid;
      if (posN <= 0 && onTile){ player.pos.y = 0; player.vel.y = 0; player.grounded = true; }
      else if (posN < -6) return crash();
      else player.grounded = false;
    }
    else if (player.surface===2){ // ceiling at y=0 (from its frame)
      if (posN >= 0){ player.pos.y = 0; player.vel.y = 0; player.grounded = true; } else if (posN > 6) return crash(); else player.grounded=false;
    }
    else if (player.surface===1){ // right wall: x=0 in its frame
      if (posN <= 0){ player.pos.x = 0; player.vel.x = 0; player.grounded = true; } else if (posN < -6) return crash(); else player.grounded=false;
    }
    else if (player.surface===3){ // left wall
      if (posN >= 0){ player.pos.x = 0; player.vel.x = 0; player.grounded = true; } else if (posN > 6) return crash(); else player.grounded=false;
    }

    // update nose marker to show center
    const localX = (player.surface===0||player.surface===2) ? player.pos.x : 0;
    const localY = (player.surface===0||player.surface===2) ? 0 : player.pos.y;
    nose.position.set(localX, 0.9 + localY*0.0, camera.position.z - 1.2);
  }

  function getFloorSegAt(z){
    if (!floorSegs.length) return null;
    // segments are spaced at SEG, starting at 0
    const idx = Math.floor(z / SEG);
    return floorSegs[idx] || null;
  }

  function rotateWorld(dir){ // dir = +1 rotate CW, -1 CCW
    // snap to boundary and rotate the world group 90 degrees around Z
    if (player.surface===0){ // floor -> wall
      player.surface = dir>0 ? 1 : 3;
      // convert floor x into wall y
      player.pos.y = clamp(dir>0 ? -CORRIDOR_HALF : CORRIDOR_HALF, -CORRIDOR_HALF, CORRIDOR_HALF);
      player.pos.x = 0; player.vel.x = 0; player.vel.y = 0; player.grounded = true;
    } else if (player.surface===2){ // ceiling -> wall
      player.surface = dir>0 ? 3 : 1;
      player.pos.y = clamp(dir>0 ? CORRIDOR_HALF : -CORRIDOR_HALF, -CORRIDOR_HALF, CORRIDOR_HALF);
      player.pos.x = 0; player.vel.x = 0; player.vel.y = 0; player.grounded = true;
    } else if (player.surface===1){ // right wall -> (dir>0 ? ceiling : floor)
      player.surface = dir>0 ? 2 : 0;
      player.pos.x = 0; player.pos.y = 0; player.vel.x = 0; player.vel.y = 0; player.grounded = true;
    } else if (player.surface===3){ // left wall -> (dir>0 ? floor : ceiling)
      player.surface = dir>0 ? 0 : 2;
      player.pos.x = 0; player.pos.y = 0; player.vel.x = 0; player.vel.y = 0; player.grounded = true;
    }

    world.rotation.z += dir * (Math.PI/2);
    showToast('Perspective shift');
  }

  // ---------- Game loop ----------
  function draw(){ renderer.render(scene,camera); }
  function loop(ts){ if (!running) return; const dt = Math.min(40, ts-last)/1000; last=ts; updatePhysics(dt);
    // progress & level endpoints
    const L = levels[currentLevel];
    const pct = Math.min(1, distance / L.length);
    progBar.style.width = (pct*100).toFixed(2) + '%';
    if (distance >= L.length){ if (currentLevel < levels.length-1){ currentLevel++; setLevelLabel(); resetLevel(currentLevel); showToast(`Level ${currentLevel} start`); } else { return completeGame(); } }
    draw(); requestAnimationFrame(loop); }

  // ---------- Init ----------
  const overlay = document.getElementById('overlay');
  const progBar = document.getElementById('prog');
  const levelLabel = document.getElementById('levelLabel');
  function showStart(){ setLevelLabel(); overlay.style.display='grid'; }
  // Start button handler (was missing)
  const startBtn = document.getElementById('startBtn');
  if (startBtn) startBtn.addEventListener('click', (e)=>{ e.preventDefault(); startGame(); });
  showStart();

})();
</script>
</body>
</html>
